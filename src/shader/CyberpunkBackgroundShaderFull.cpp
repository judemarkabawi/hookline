#include "CyberpunkBackgroundShaderFull.hpp"

#include "util/gl_compile_program.hpp"

CyberpunkBackgroundShaderFull::CyberpunkBackgroundShaderFull() {
    m.program = gl_compile_program(
        // vertex shader
        "#version 330 \n"
        "in vec2 a_position; \n"
        "void main() { \n"
        "   gl_Position = vec4(a_position, 0.0, 1.0); \n"
        "}\n",
        // ----- Fragment shader ---------------------------------------------------------
        "#version 330 \n"
        "uniform float u_time; \n"
        "uniform vec2 u_drawable_size; \n"
        "out vec4 FragColor; \n"
        "uniform vec2 u_camera_pos;\n"
        "\n"
        "\n"
        "\n"
        "uniform sampler2D u_bg_emission;\n"
        "uniform sampler2D u_bg_color;\n"
        "uniform sampler2D u_bg_normal;\n"
        "\n"
        "uniform sampler2D u_mg_emission;\n"
        "uniform sampler2D u_mg_color;\n"
        "uniform sampler2D u_mg_normal;\n"
        "\n"
        "uniform sampler2D u_fg_emission;\n"
        "uniform sampler2D u_fg_color;\n"
        "uniform sampler2D u_fg_normal;\n"
        "\n"
        "uniform samplerCube u_bg_cube;\n"
        "\n"
        "// cosine based palette, 4 vec3 params\n"
        "//from https://iquilezles.org/articles/palettes/\n"
        "//and http://dev.thi.ng/gradients/\n"
        "vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n"
        "{\n"
        "    return a + b*cos( 6.283185*(c*t+d) );\n"
        "}\n"
        "\n"
        "vec3 hex_palette(float t) {\n"
        "    vec3 a = vec3(0.5,0.5,0.5);\n"
        "    vec3 b = vec3(0.5,0.5,0.5);\n"
        "    vec3 c = vec3(1.0,1.0,1.0);\n"
        "    vec3 d = vec3(0.0,0.10,0.20);\n"
        "    vec3 col = palette(t, a, b, c, d);\n"
        "    return col;\n"
        "}\n"
        "\n"
        "vec3 hex_palette2(float t) {\n"
        "    vec3 a = vec3(0.748, 0.688, 0.778);\n"
        "    vec3 b = vec3(0.228, 0.228, -0.282);\n"
        "    vec3 c = vec3(1.448, 0.468, 0.438);\n"
        "    vec3 d = vec3(0.518, 0.578, 0.008);\n"
        "    vec3 col = palette(t, a, b, c, d);\n"
        "    return vec3(clamp(col.x, 0.0, 1.0), clamp(col.y, 0.0, 1.0), clamp(col.z, 0.0, 1.0));\n"
        "}\n"
        "\n"
        "vec3 hex_palette3(float t) {\n"
        "    vec3 a = vec3(1.0,0.5,0.5);\n"
        "    vec3 b = vec3(0.5,0.5,0.5);\n"
        "    vec3 c = vec3(1.0,1.0,1.0);\n"
        "    vec3 d = vec3(0.0,0.10,0.20);\n"
        "    vec3 col = palette(t, a, b, c, d);\n"
        "    return col;\n"
        "}\n"
        "\n"
        "vec3 hex_palette4(float t) {\n"
        "    vec3 a = vec3(0.718, 0.478, 0.628);\n"
        "    vec3 b = vec3(0.288, 0.528, -0.102);\n"
        "    vec3 c = vec3(0.558, 0.498, 0.438);\n"
        "    vec3 d = vec3(0.548, 0.548, 0.008);\n"
        "    vec3 col = palette(t, a, b, c, d);\n"
        "    return col;\n"
        "}\n"
        "\n"
        "vec3 env_pallette(float t) {\n"
        "    vec3 a = vec3(0.388, 0.508, 0.338);\n"
        "    vec3 b = vec3(-0.532, 0.248, 0.308);\n"
        "    vec3 c = vec3(0.338, 1.178, 0.838);\n"
        "    vec3 d = vec3(1.538, 0.978, 1.148);\n"
        "    vec3 col = palette(t, a, b, c, d);\n"
        "    return vec3(clamp(col.x, 0.0, 1.0), clamp(col.y, 0.0, 1.0), clamp(col.z, 0.0, 1.0));\n"
        "}\n"
        "\n"
        "\n"
        "float inBeehive(float u, float v, float sqh, float borderWidth) {\n"
        "   bool up = abs(v - 0.5) <= ((1.0 - (sqh+borderWidth/2.0)))*(0.5 - abs(u - 0.5)) + (sqh+borderWidth/2.0)/2.0;\n"
        "   bool lo = abs(v - 0.5) <= ((1.0 - (sqh+borderWidth/2.0)))*(0.5 - abs(u - 0.5)) + (sqh-borderWidth/2.0)/2.0;\n"
        "   float t = (abs(v - 0.5) - ((1.0-sqh)*(0.5 - abs(u - 0.5)) + sqh/2.0 - borderWidth/2.0));\n"
        "   t = clamp(t/(borderWidth/2.0), 0.0, 1.0);\n"
        "   bool h = ((borderWidth/2.0 <= u) && (u <= 1.0-(borderWidth/2.0)));\n"
        "   float b = max(min((u/(borderWidth/2.0)), 1.0f)*min(float((1.0-u)/(borderWidth/2.0)), 1.0), 0.0);\n"
        "   //not on border\n"
        "   return max(t, (1.0-b));\n"
        "}\n"
        "\n"
        "\n"
        "float dist(float x1, float y1, float x2, float y2) {\n"
        "    return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n"
        "}\n"
        "\n"
        "float remap(float x, float i_s, float i_e, float o_s, float o_e) {\n"
        "    return o_s + ((x - i_s)/(i_e - i_s))*(o_e-o_s);\n"
        "}\n"
        "\n"
        "vec3 remap(vec3 x, float i_s, float i_e, float o_s, float o_e) {\n"
        "    return o_s + ((x - i_s)/(i_e - i_s))*(o_e-o_s);\n"
        "}\n"
        "\n"
        "vec4 hex_shader(vec2 uv, float iTime, vec3 norm, float scale, int type)\n"
        "{\n"
        "    float borderWidth = 0.1;\n"
        "    float sqh = 0.6;\n"
        "\n"
        "    // Normalized pixel coordinates (from 0 to 1)\n"
        "    float u = uv.x;\n"
        "    float v = uv.y;\n"
        "    \n"
        "    \n"
        "    \n"
        "    float warp = 0.0f;//0.3*cos(iTime*0.3)*((sin(iTime*10.0)+1.0)/2.0);\n"
        "    \n"
        "    float off = sin(3.141592*(uv.x + 1.0)) + 1.0;\n"
        "    //v += 0.5*off*off*sin(3.141592*(uv.y - 0.5));\n"
        "    v = min(v/(1.0 - warp*off*0.5), 1000.0);\n"
        "    u = min(u/(1.0 - warp*off*0.7), 1000.0);\n"
        "    \n"
        "    u *= scale;\n"
        "    v *= scale;\n"
        "    \n"
        "    u *= remap(abs(norm.y), 0.0, 1.0, 1.0, 1.0);\n"
        "    v *= remap(abs(norm.z), 0.0, 1.0, 1.0, 1.0);\n"
        "    \n"
        "    float u_tot = u;\n"
        "    float v_tot = v;\n"
        "    \n"
        "    \n"
        "    u = fract(u + 1.0f);\n"
        "    v = mod(v, 1.0 + sqh);\n"
        "    \n"
        "    float u2 = u + 0.5;\n"
        "    float v2 = v_tot - (sqh + ((1.0-sqh)/2.0));//, 1.0 + sqh + borderWidth);\n"
        "    \n"
        "    float u2_tot = u_tot + 0.5;\n"
        "    float v2_tot = v2;\n"
        "    \n"
        "    u2 = fract(u2);\n"
        "    v2 = mod(v2, 1.0 + sqh);\n"
        "    \n"
        "    // Time varying pixel color\n"
        "    vec3 border_dist = vec3(inBeehive(u, v, sqh, borderWidth)*inBeehive(u2, v2, sqh, borderWidth));\n"
        "    float uv_hex_dist = inBeehive(u, v, sqh, 1.0);\n"
        "    float uv2_hex_dist = inBeehive(u2, v2, sqh, 1.0);\n"
        "    vec3 hex_dist = vec3(1.0 - clamp((uv_hex_dist*uv2_hex_dist)/(1.0-borderWidth/2.0), 0.0, 1.0));\n"
        "    vec3 circle_dist = 1.0 - vec3(min(dist(u, v, 0.5, 0.5)*0.5, dist(u2, v2, 0.5, 0.5)*0.5));\n"
        "    hex_dist = (hex_dist+circle_dist)/2.0;\n"
        "    hex_dist = remap(hex_dist, 0.1, 1.0, 0.2, 1.5);\n"
        "    hex_dist = hex_dist*(float(border_dist.x <= 0.0));\n"
        "    border_dist = remap(border_dist, 0.0, 1.0, 0.2, 1.0);\n"
        "    \n"
        "    float sects = 13.0;\n"
        "    u_tot += floor(sects/2.0);\n"
        "    v_tot += floor(sects/2.0);\n"
        "    u2_tot += floor(sects/2.0);\n"
        "    v2_tot += floor(sects/2.0);\n"
        "    \n"
        "    float u_idx = round(u_tot - 0.5);\n"
        "    float v_idx = round((v_tot-0.5)/(1.0+sqh));\n"
        "    float u2_idx = round(u2_tot - 0.5);\n"
        "    float v2_idx = round((v2_tot-0.5)/(1.0+sqh));\n"
        "    \n"
        "    //vec3 uv_col = 1.3*vec3(u_idx/10.0, v_idx/10.0, 1.0);\n"
        "    //vec3 uv2_col = 1.3*vec3(u2_idx/10.0, v2_idx/10.0, 0.0);\n"
        "    \n"
        "    \n"
        "    \n"
        "    float uv_mask = float(uv_hex_dist < 1.0);\n"
        "    float uv2_mask = float(uv2_hex_dist < 1.0);\n"
        "    \n"
        "    float t = 0.3*iTime;\n"
        "    \n"
        "    float uv_idx =  (dist(u_idx/sects, v_idx/sects, 2.*cos(2.*t), 2.*sin(2.*t))*0.5) + t ;\n"
        "    float uv2_idx = (dist(u2_idx/sects, v2_idx/sects, 2.*cos(2.*t+0.2), 2.*sin(2.*t+0.2))*0.5) + t;\n"
        "    \n"
        "    vec3 uv_color = vec3(0.0);\n"
        "    vec3 uv2_color = vec3(0.0);\n"
        "    if(type == 0) {\n"
        "        uv_color = hex_palette(fract(uv_idx));\n"
        "        uv2_color = hex_palette(fract(uv2_idx));\n"
        "    } else if (type == 1) {\n"
        "        uv_color = hex_palette2(fract(uv_idx));\n"
        "        uv2_color = hex_palette2(fract(uv2_idx));\n"
        "    } else if(type == 2) {\n"
        "        uv_color = hex_palette3(fract(uv_idx));\n"
        "        uv2_color = hex_palette3(fract(uv2_idx));\n"
        "    } else if(type == 3) {\n"
        "        uv_color = hex_palette4(fract(uv_idx));\n"
        "        uv2_color = hex_palette4(fract(uv2_idx));\n"
        "    }\n"
        "    \n"
        "    vec3 hex_col = (uv_mask*uv_color + uv2_mask*uv2_color)*max(hex_dist.x, 0.0);\n"
        "    hex_col = clamp(hex_col, vec3(0.0), vec3(1.0));\n"
        "    \n"
        "    vec3 border_col = vec3(0.8, 0.3, 0.0)*remap(border_dist, 0.0, 0.9, 0.0, 0.7);\n"
        "    vec3 col = (hex_col + float(border_dist.x>0.0)*border_col);\n"
        "    \n"
        "    //col = vec3(uu, v, 1.0);\n"
        "    // Output to screen\n"
        "    return vec4(col,1.0);\n"
        "}\n"
        "\n"
        "vec4 hex_shader2(vec2 uv, float iTime, float scale)\n"
        "{\n"
        "    // Normalized pixel coordinates (from 0 to 1)\n"
        "    float u = uv.x;\n"
        "    float v = uv.y;\n"
        "    \n"
        "    \n"
        "    float scale_x = scale;\n"
        "    float scale_y = scale;\n"
        "    float sqh = 0.0;\n"
        "    float borderWidth = 1.0;\n"
        "    \n"
        "    v += 0.04*sin(((u+0.02*iTime)*4.0 + 0.5)*3.141592);\n"
        "    u += 0.02*sin(((v+0.05*iTime)*4.0 + 0.5)*3.141592);\n"
        "    u *= 1.0 - 0.1*((sin(((u)*2.0 + 0.5)*3.141592)+1.0)/2.0);\n"
        "    \n"
        "    \n"
        "    float warp = 0.0f;\n"
        "    \n"
        "    float off = sin(3.141592*(uv.x + 1.0)) + 1.0;\n"
        "\n"
        "    v = min(v/(1.0 - warp*off*0.5), 1000.0);\n"
        "    u = min(u/(1.0 - warp*off*0.7), 1000.0);\n"
        "\n"
        "    \n"
        "    u *= scale_x;\n"
        "    v *= scale_y;\n"
        "   \n"
        "    \n"
        "    float u_tot = u;\n"
        "    float v_tot = v;\n"
        "   \n"
        "    u = fract(u + 1.0f);\n"
        "    v = mod(v, 1.0 + sqh);\n"
        "    \n"
        "    float u2 = u + 0.5;\n"
        "    float v2 = v_tot - (sqh + ((1.0-sqh)/2.0));//, 1.0 + sqh + borderWidth);\n"
        "    \n"
        "    float u2_tot = u_tot + 0.5;\n"
        "    float v2_tot = v2;\n"
        "    \n"
        "    u2 = fract(u2);\n"
        "    v2 = mod(v2, 1.0 + sqh);\n"
        "    \n"
        "    // Time varying pixel color\n"
        "    vec3 border_dist = vec3(inBeehive(u, v, sqh, borderWidth)*inBeehive(u2, v2, sqh, borderWidth));\n"
        "    float uv_hex_dist = inBeehive(u, v, sqh, 1.0);\n"
        "    float uv2_hex_dist = inBeehive(u2, v2, sqh, 1.0);\n"
        "    vec3 hex_dist = vec3(1.0 - clamp((uv_hex_dist*uv2_hex_dist)/(1.0-borderWidth/2.0), 0.0, 1.0));\n"
        "    vec3 circle_dist = 1.0 - vec3(min(dist(u, v, 0.5, 0.5)*0.5, dist(u2, v2, 0.5, 0.5)*0.5));\n"
        "    hex_dist = (hex_dist+circle_dist)/2.0;\n"
        "    //hex_dist = remap(hex_dist, 0.1, 1.0, 0.2, 1.5);\n"
        "    hex_dist = hex_dist*(float(border_dist.x <= 0.0));\n"
        "    border_dist = remap(border_dist, 0.0, 1.0, 0.2, 1.0);\n"
        "    \n"
        "    float d = remap(hex_dist.x + border_dist.x, 0.5, 1.0, 0.0, 1.0);\n"
        "    \n"
        "    \n"
        "    float b = clamp(pow(d, 3.0), 0.0, 1.0);\n"
        "    float c = abs(d - (0.8*((sin(iTime)+1.0)/2.0) + 0.4*(cos(u_tot + v_tot - iTime)+1.0)/2.0));\n"
        "    \n"
        "    c = 0.1*b + (1.0 - c*6.0);\n"
        "    c += d*0.25;\n"
        "    //c = clamp(c, 0.0, 1.0);\n"
        "    c = 0.4/(1.0-min(c, 0.999));\n"
        "    c = clamp(c, 0.0, 1.0);\n"
        "    \n"
        "    vec3 col = 1.0*(0.4*c+0.6)*hex_palette2(c);\n"
        "    \n"
        "    // Output to screen\n"
        "    return vec4(col,1.0);\n"
        "}\n"
        "\n"
        "\n"
        "void render_layer(out vec4 color, out float alpha, in float dist, vec2 uv, in vec2 cameraPos, in float MAX_FOG_DIST, in float iTime, \n"
        "                  in sampler2D emissionTex, in sampler2D colorTex, in sampler2D normalTex, in samplerCube u_bg_cube) {\n"
        "    vec2 uv0 = uv;\n"
        "    uv *= dist/MAX_FOG_DIST;\n"
        "    uv += cameraPos*(1.0/dist);\n"
        "    \n"
        "    vec2 texR = vec2(16.0/9.0, 1.0);\n"
        "    vec2 _uv_ = vec2(uv.x / texR.x, uv.y / texR.y);\n"
        "    _uv_ = vec2(mod(_uv_.x, 1.0), _uv_.y);\n"
        "    vec4 _mat_ = texture(emissionTex, _uv_); \n"
        "    vec3 albedo = texture(colorTex, _uv_).xyz;\n"
        "    vec4 _norm_and_ambient_ = texture(normalTex, _uv_);\n"
        "    vec3 mat = _mat_.xyz;\n"
        "    alpha = _mat_.w;\n"
        "    float ambient = _norm_and_ambient_.w;\n"
        "    vec3 norm_col = _norm_and_ambient_.xyz;\n"
        "    \n"
        "    \n"
        "    \n"
        "    //change normals to -1 to range\n"
        "    bool is_building_mat = mat.r > 0.5 && mat.g > 0.5 && mat.b > 0.5;\n"
        "    bool is_void = (mat.r < 0.1) && (mat.g < 0.1) && (mat.b < 0.1);\n"
        "    alpha = is_void ? 0.0 : alpha;\n"
        "    vec3 norm_vec = norm_col*2.0 - 1.0;\n"
        "    norm_vec = norm_vec == vec3(0.0) || is_void ? vec3(0.0) : normalize(norm_vec);\n"
        "    vec3 view_vec = normalize(vec3(-1.0, uv0 - vec2(0.5, 0.25))).xzy;\n"
        "    vec3 reflect_vec = reflect(view_vec, norm_vec.xzy);\n"
        "    \n"
        "    float rot = 3.141592/1.5;\n"
        "    vec3 sunDir1 = normalize(vec3(cos(rot + iTime*0.05), sin(rot + iTime*0.05), 1.0));\n"
        "    vec3 sunDir2 = normalize(vec3(cos(rot + 1.7 + iTime*0.05), sin(rot + 1.7 + iTime*0.05), 1.0));\n"
        "    \n"
        "    vec3 lumaCoeff = vec3(0.2126, 0.7152, 0.0722);\n"
        "    float luma = dot(albedo,lumaCoeff);\n"
        "    vec3 albedoFlat = !is_void ? clamp(albedo/luma, vec3(0.0), vec3(1.0)) : vec3(0.0);\n"
        "    float lightness = max(dot(norm_vec, sunDir1), 0.0);// + max(dot(norm_vec, sunDir2), 0.0);\n"
        "    //lightness *= 0.4;\n"
        "    lightness += luma*0.6;\n"
        "    //lightness += ambient;\n"
        "    //lightness *= 0.5;\n"
        "    //lightness += 0.5;\n"
        "    \n"
        "    \n"
        "    vec3 col = albedoFlat*lightness;\n"
        "    \n"
        "    vec3 emission = vec3(0.0);\n"
        "    if(is_building_mat) {\n"
        "\n"
        "    } else if (mat.b > 0.5 && mat.g > 0.5) {\n"
        "        emission = hex_shader(uv, u_time, norm_vec, dist*2.0, 0).xyz;\n"
        "    } else if (mat.b > 0.5) {\n"
        "        emission = hex_shader(uv, u_time, norm_vec, dist*2.0, 3).xyz;\n"
        "    } else if (mat.g > 0.5) {\n"
        "        emission = hex_shader2(uv, u_time, dist).xyz;\n"
        "    } else if (mat.r > 0.5) {\n"
        "        emission = texture(u_bg_cube, reflect_vec).xyz*0.6;\n"
        "    } else {\n"
        "        emission = texture(u_bg_cube, view_vec).xyz;\n"
        "        //alpha = 0.0;\n"
        "    }\n"
        "    \n"
        "    dist = alpha > 0.0 ? dist : MAX_FOG_DIST;\n"
        "    float fog_factor = uv0.y*0.6*pow(dist/MAX_FOG_DIST, 1.5);\n"
        "    vec3 fog = env_pallette(fog_factor)*vec3(1.1);// + vec3(0.1, 0.1, 0.05);\n"
        "    float fog_amt = 0.9;\n"
        "    \n"
        "    col += emission;\n"
        "    \n"
        "    col = mix(col, fog, fog_amt*(dist/MAX_FOG_DIST));\n"
        "    col = mix(col, fog, 0.15 + (dist/MAX_FOG_DIST)*min(2.0*fog_amt*(1.0 - pow(uv.y, 0.2)), 1.0));\n"
        "    \n"
        "\n"
        "    // Output to screen\n"
        "    color = vec4(vec3(col), alpha);\n"
        "}\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "void main()\n"
        "{\n"
        "    // Normalized pixel coordinates (from 0 to 1)\n"
        "    float minR = min(u_drawable_size.x, u_drawable_size.y);\n"
        "    float maxR = max(u_drawable_size.x, u_drawable_size.y);\n"
        "    float aspect_ratio = maxR / minR;\n"
        "    \n"
        "    vec2 uv = vec2(gl_FragCoord.xy)/minR;\n"
        "    float MAX_FOG_DIST = 170.0;\n"
        "    \n"
        "    \n"
        "    \n"
        "    vec4 color = vec4(0.0);\n"
        "    float alpha = 0.0;\n"
        "    //bg\n"
        "    render_layer(color, alpha, 120.0, uv, u_camera_pos, MAX_FOG_DIST, u_time, u_bg_emission, u_bg_color, u_bg_normal, u_bg_cube);\n"
        "    FragColor = vec4(color.xyz, 1.0);\n"
        "    \n"
        "    //mg\n"
        "    render_layer(color, alpha, 80.0, uv + 0.5*u_drawable_size.xy/minR + vec2(0.5, 0.0), u_camera_pos, MAX_FOG_DIST, u_time, u_mg_emission, u_mg_color, u_mg_normal, u_bg_cube);\n"
        "    if(alpha > 0.0) FragColor = mix(FragColor, vec4(vec3(color.xyz), 1.0), alpha);\n"
        "    \n"
        "    //fg\n"
        "    render_layer(color, alpha, 30.0, uv + 0.5*u_drawable_size.xy/minR, u_camera_pos, MAX_FOG_DIST, u_time, u_fg_emission, u_fg_color, u_fg_normal, u_bg_cube);\n"
        "    if(alpha > 0.0) FragColor = mix(FragColor, vec4(vec3(color.xyz), 1.0), alpha);\n"
        "}\n");

    //positional uniforms
    m.a_position_loc = glGetAttribLocation(m.program, "a_position");
    m.u_time_loc = glGetUniformLocation(m.program, "u_time");
    m.u_drawable_size_loc = glGetUniformLocation(m.program, "u_drawable_size");
    m.u_camera_pos = glGetUniformLocation(m.program, "u_camera_pos");

    //texture uniforms
    m.u_bg_emission = glGetUniformLocation(m.program, "u_bg_emission");
    m.u_bg_color = glGetUniformLocation(m.program, "u_bg_color");
    m.u_bg_normal = glGetUniformLocation(m.program, "u_bg_normal");

    m.u_mg_emission = glGetUniformLocation(m.program, "u_mg_emission");
    m.u_mg_color = glGetUniformLocation(m.program, "u_mg_color");
    m.u_mg_normal = glGetUniformLocation(m.program, "u_mg_normal");

    m.u_fg_emission = glGetUniformLocation(m.program, "u_fg_emission");
    m.u_fg_color = glGetUniformLocation(m.program, "u_fg_color");
    m.u_fg_normal = glGetUniformLocation(m.program, "u_fg_normal");

    m.u_bg_cube = glGetUniformLocation(m.program, "u_bg_cube");

    //set TEX to always refer to texture binding zero:
	glUseProgram(m.program); //bind program -- glUniform* calls refer to this program now

	glUniform1i(m.u_bg_emission, 0); 
    glUniform1i(m.u_bg_color, 1);
    glUniform1i(m.u_bg_normal, 2);
    glUniform1i(m.u_mg_emission, 3); 
    glUniform1i(m.u_mg_color, 4);
    glUniform1i(m.u_mg_normal, 5);
    glUniform1i(m.u_fg_emission, 6); 
    glUniform1i(m.u_fg_color, 7);
    glUniform1i(m.u_fg_normal, 8);
    glUniform1i(m.u_bg_cube, 9);

	glUseProgram(0); //unbind program -- glUniform* calls refer to ??? now
}

CyberpunkBackgroundShaderFull::~CyberpunkBackgroundShaderFull() {
    glDeleteProgram(m.program);
}

CyberpunkBackgroundShaderFull::CyberpunkBackgroundShaderFull(
    CyberpunkBackgroundShaderFull&& other) noexcept
    : m(std::move(other.m)) {
    other.m.program = 0;
}

CyberpunkBackgroundShaderFull& CyberpunkBackgroundShaderFull::operator=(
    CyberpunkBackgroundShaderFull&& other) noexcept {
    if (this == &other) {
        return *this;
    }

    // Delete current program
    glDeleteProgram(m.program);

    // Move
    m = std::move(other.m);

    // Reset other
    other.m.program = 0;

    return *this;
}